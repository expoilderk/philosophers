Em qual parte desse código está acontecendo data races :

#ifndef PHILO_H
#define PHILO_H

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/time.h>

#define INT_MIN -2147483648
#define INT_MAX 2147483647

    typedef struct s_rules
{
    int num_philosophers;
    int time_to_die;
    int time_to_eat;
    int time_to_sleep;
    int num_times_eat;
    int all_satisfied;
    int finish;
    long start_time;
    pthread_mutex_t *m_forks;
    pthread_mutex_t m_print;
    pthread_mutex_t m_check;
    pthread_mutex_t m_finish;
} t_rules;

typedef struct s_philo
{
    int id;
    int times_eaten;
    long last_meal;
    int left_fork;
    int right_fork;
    t_rules *rules;
    pthread_t thread_philo;
} t_philo;

// Init & Finish
void init(char **argv, t_rules *rules);
void init_rules(char **argv, t_rules *rules);
void init_threads(t_rules *rules);
void init_mutex(t_rules *rules);
void finish(t_rules *rules);

// Threads routines
void *dinner(void *arg);
void *monitor(void *arg);
int check_finish(t_rules *rules);
void waiter(t_rules *rules);

// Actions
void take_fork(t_rules *rules, t_philo *philo);
void eat(t_rules *rules, t_philo *philo);
void sleeping_and_thinking(t_rules *rules, t_philo *philo);

// Time
long timestamp(void);
long time_diff(long start, long end);
void smart_sleep(int ms);

// Checks
int check(char **argv, int i, int j);
void error_msg(void);
void help_msg(void);

// Utils
void lock_print(t_rules *rules, int id, char *string);
long ft_atoi_l(const char *str);
int ft_isdigit(int c);
int ft_issign(char c);

#endif

void take_fork(t_rules *rules, t_philo *philo)
{
    pthread_mutex_lock(&rules->m_forks[philo->left_fork]);
    lock_print(rules, philo->id, "has taken a fork");
    if (rules->num_philosophers == 1)
    {
        smart_sleep(rules->time_to_die * 2);
        return;
    }
    pthread_mutex_lock(&rules->m_forks[philo->right_fork]);
    lock_print(rules, philo->id, "has taken a fork");
}

void eat(t_rules *rules, t_philo *philo)
{
    pthread_mutex_lock(&rules->m_check);
    lock_print(rules, philo->id, "is eating");
    philo->last_meal = timestamp();
    philo->times_eaten++;
    if (philo->times_eaten == rules->num_times_eat)
        rules->all_satisfied++;
    smart_sleep(rules->time_to_eat);
    pthread_mutex_unlock(&rules->m_check);
    pthread_mutex_unlock(&rules->m_forks[philo->left_fork]);
    pthread_mutex_unlock(&rules->m_forks[philo->right_fork]);
}

void sleeping_and_thinking(t_rules *rules, t_philo *philo)
{
    lock_print(rules, philo->id, "is sleeping");
    smart_sleep(rules->time_to_sleep);
    lock_print(rules, philo->id, "is thinking");
}

int check(char **argv, int i, int j)
{
    long int value;
    int flag;

    flag = 1;
    while (argv[++i])
    {
        j = 0;
        value = ft_atoi_l(argv[i]);
        if (value < INT_MIN || value > INT_MAX)
            flag = 0;
        if (ft_issign(argv[i][j]) && argv[i][j + 1] != '\0')
        {
            flag = 0;
            j++;
        }
        while (argv[i][j] && ft_isdigit(argv[i][j]))
            j++;
        if (argv[i][j] != '\0' && !ft_isdigit(argv[i][j]))
            flag = 0;
    }
    if (!flag)
        error_msg();
    return (flag);
}

void error_msg(void)
{
    printf("Invalid Arguments!\n");
}

void help_msg(void)
{
    printf("Usage: ./philo <num_of_philo> <time_to_die> <time_to_eat> \
<time_to_sleep> [num_times_philo_should_sleep]\n");
}

void *dinner(void *arg)
{
    t_philo *philo;

    philo = (t_philo *)arg;
    if (philo->id % 1 && philo->rules->num_philosophers > 1)
        usleep(philo->rules->time_to_eat);
    while (1)
    {
        if (check_finish(philo->rules))
            break;
        take_fork(philo->rules, philo);
        eat(philo->rules, philo);
        sleeping_and_thinking(philo->rules, philo);
    }
    return (NULL);
}

int check_finish(t_rules *rules)
{
    pthread_mutex_lock(&rules->m_finish);
    if (rules->finish)
    {
        pthread_mutex_unlock(&rules->m_finish);
        return (1);
    }
    pthread_mutex_unlock(&rules->m_finish);
    return (0);
}

void waiter(t_rules *rules)
{
    pthread_mutex_lock(&rules->m_check);
    if (rules->all_satisfied == rules->num_philosophers)
    {
        pthread_mutex_lock(&rules->m_finish);
        rules->finish = 1;
        pthread_mutex_unlock(&rules->m_finish);
    }
    pthread_mutex_unlock(&rules->m_check);
}

void *monitor(void *arg)
{
    t_philo *philo;

    philo = (t_philo *)arg;
    while (1)
    {
        if (check_finish(philo->rules))
            break;
        waiter(philo->rules);
        pthread_mutex_lock(&philo->rules->m_check);
        if (!philo->rules->finish && timestamp() -
                                             philo->last_meal >
                                         philo->rules->time_to_die)
        {
            lock_print(philo->rules, philo->id, "died");
            pthread_mutex_lock(&philo->rules->m_finish);
            philo->rules->finish = 1;
            pthread_mutex_unlock(&philo->rules->m_finish);
        }
        pthread_mutex_unlock(&philo->rules->m_check);
        usleep(100);
    }
    return (NULL);
}

void finish(t_rules *rules)
{
    int i;

    i = 0;
    while (i < rules->num_philosophers)
    {
        pthread_mutex_destroy(&rules->m_forks[i]);
        i++;
    }
    pthread_mutex_destroy(&rules->m_print);
    pthread_mutex_destroy(&rules->m_check);
    pthread_mutex_destroy(&rules->m_finish);

    free(rules->m_forks);
}

void init(char **argv, t_rules *rules)
{
    rules->start_time = timestamp();
    init_rules(argv, rules);
    init_mutex(rules);
    init_threads(rules);
}

void init_rules(char **argv, t_rules *rules)
{
    rules->num_philosophers = (int)ft_atoi_l(argv[1]);
    rules->time_to_die = (int)ft_atoi_l(argv[2]);
    rules->time_to_eat = (int)ft_atoi_l(argv[3]);
    rules->time_to_sleep = (int)ft_atoi_l(argv[4]);
    rules->finish = 0;
    rules->all_satisfied = 0;
    if (argv[5])
        rules->num_times_eat = (int)ft_atoi_l(argv[5]);
    else
        rules->num_times_eat = -1;
}

void init_threads(t_rules *rules)
{
    int i;
    pthread_t thread_waiter;
    t_philo *philo;

    i = 0;
    philo = malloc(sizeof(t_philo) * rules->num_philosophers);
    while (i < rules->num_philosophers)
    {
        philo[i].id = i + 1;
        philo[i].left_fork = i;
        philo[i].right_fork = (i + 1) % rules->num_philosophers;
        philo[i].times_eaten = 0;
        philo[i].rules = rules;
        pthread_create(&philo[i].thread_philo, NULL, dinner,
                       &philo[i]);
        philo[i].last_meal = timestamp();
        pthread_create(&thread_waiter, NULL, monitor, &philo[i]);
        pthread_detach(thread_waiter);
        i++;
    }
    i = 0;
    while (i < rules->num_philosophers)
    {
        pthread_join(philo[i].thread_philo, NULL);
        i++;
    }
    free(philo);
}

void init_mutex(t_rules *rules)
{
    int i;

    i = 0;
    rules->m_forks = malloc(sizeof(pthread_mutex_t) * rules->num_philosophers);
    while (i < rules->num_philosophers)
        pthread_mutex_init(&rules->m_forks[i++], NULL);
    pthread_mutex_init(&rules->m_print, NULL);
    pthread_mutex_init(&rules->m_check, NULL);
    pthread_mutex_init(&rules->m_finish, NULL);
}

long timestamp(void)
{
    struct timeval time;

    gettimeofday(&time, NULL);
    return ((time.tv_sec * 1000) + (time.tv_usec / 1000));
}

long time_diff(long start, long end)
{
    return (end - start);
}

void smart_sleep(int ms)
{
    long int time;

    time = timestamp();
    while (timestamp() - time < ms)
        usleep(ms / 10);
}

void lock_print(t_rules *rules, int id, char *string)
{
    pthread_mutex_lock(&rules->m_print);
    pthread_mutex_lock(&rules->m_finish);
    if (!rules->finish)
        printf("%ld %d %s\n", timestamp() - rules->start_time, id, string);
    pthread_mutex_unlock(&rules->m_finish);
    pthread_mutex_unlock(&rules->m_print);
}

long ft_atoi_l(const char *str)
{
    long int sum;
    int i;
    int sign;

    sum = 0;
    i = 0;
    sign = 1;
    while (str[i] == ' ' || (str[i] >= '\t' && str[i] <= '\r'))
        i++;
    if (str[i] == '+' || str[i] == '-')
    {
        if (str[i] == '-')
            sign = -1;
        i++;
    }
    while (str[i] >= '0' && str[i] <= '9')
    {
        sum = (sum * 10) + (str[i] - '0');
        i++;
    }
    return (sign * sum);
}

int ft_isdigit(int c)
{
    if (c >= 48 && c <= 57)
        return (2048);
    return (0);
}

int ft_issign(char c)
{
    if (c == '+' || c == '-')
        return (1);
    return (0);
}

int main(int argc, char **argv)
{
    t_rules rules;

    if (argc < 5 || argc > 6)
    {
        help_msg();
        return (0);
    }
    if (!check(argv, 0, 0))
        return (0);
    init(argv, &rules);
    finish(&rules);
    return (0);
}

Essa é a mensagem do helgrind :

    == 3896 == Helgrind,
    a thread error detector == 3896 == Copyright(C) 2007 - 2017, and GNU GPL'd, by OpenWorks LLP et al. == 3896 == Using Valgrind - 3.18.1 and LibVEX; rerun with -h for copyright info
==3896== Command: ./philo 2 800 200 200 3
==3896==
13 1 has taken a fork
23 1 has taken a fork
24 1 is eating
==3896== ---Thread-Announcement------------------------------------------
==3896==
==3896== Thread #2 was created
==3896==    at 0x498ABA3: clone (clone.S:76)
==3896==    by 0x498BA9E: __clone_internal (clone-internal.c:83)
==3896==    by 0x48F9758: create_thread (pthread_create.c:295)
==3896==    by 0x48FA27F: pthread_create@@GLIBC_2.34 (pthread_create.c:828)
==3896==    by 0x4853767: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==3896==    by 0x109C5F: init_threads (in /home/philosophers/philo/philo)
==3896==    by 0x109A17: init (in /home/philosophers/philo/philo)
==3896==    by 0x109E95: main (in /home/philosophers/philo/philo)
==3896==
==3896== ---Thread-Announcement------------------------------------------
==3896==
==3896== Thread #1 is the program's root thread
==3896==
==3896== ----------------------------------------------------------------
==3896==
==3896==  Lock at 0x4A90040 was first observed
==3896==    at 0x4854BFE: pthread_mutex_init (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==3896==    by 0x109DC2: init_mutex (in /home/philosophers/philo/philo)
==3896==    by 0x109A0B: init (in /home/philosophers/philo/philo)
==3896==    by 0x109E95: main (in /home/philosophers/philo/philo)
==3896==  Address 0x4a90040 is 0 bytes inside a block of size 80 alloc'd
==3896==    at 0x484A919: malloc (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==3896==    by 0x109D83: init_mutex (in /home/philosophers/philo/philo)
==3896==    by 0x109A0B: init (in /home/philosophers/philo/philo)
==3896==    by 0x109E95: main (in /home/philosophers/philo/philo)
==3896==  Block was alloc'd by thread #1
==3896==
==3896==  Lock at 0x4A90068 was first observed
==3896==    at 0x4854BFE: pthread_mutex_init (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==3896==    by 0x109DC2: init_mutex (in /home/philosophers/philo/philo)
==3896==    by 0x109A0B: init (in /home/philosophers/philo/philo)
==3896==    by 0x109E95: main (in /home/philosophers/philo/philo)
==3896==  Address 0x4a90068 is 40 bytes inside a block of size 80 alloc'd
==3896==    at 0x484A919: malloc (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==3896==    by 0x109D83: init_mutex (in /home/philosophers/philo/philo)
==3896==    by 0x109A0B: init (in /home/philosophers/philo/philo)
==3896==    by 0x109E95: main (in /home/philosophers/philo/philo)
==3896==  Block was alloc'd by thread #1
==3896==
==3896==  Lock at 0x1FFF0004F8 was first observed
==3896==    at 0x4854BFE: pthread_mutex_init (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==3896==    by 0x109DF7: init_mutex (in /home/philosophers/philo/philo)
==3896==    by 0x109A0B: init (in /home/philosophers/philo/philo)
==3896==    by 0x109E95: main (in /home/philosophers/philo/philo)
==3896==  Address 0x1fff0004f8 is on thread #1's stack
==3896==  in frame #7, created by main (???:)
==3896==
==3896== Possible data race during write of size 8 at 0x4A900D8 by thread #2
==3896== Locks held: 3, at addresses 0x4A90040 0x4A90068 0x1FFF0004F8
==3896==    at 0x1093F0: eat (in /home/philosophers/philo/philo)
==3896==    by 0x109747: dinner (in /home/philosophers/philo/philo)
==3896==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==3896==    by 0x48F9B42: start_thread (pthread_create.c:442)
==3896==    by 0x498ABB3: clone (clone.S:100)
==3896==
==3896== This conflicts with a previous write of size 8 by thread #1
==3896== Locks held: none
==3896==    at 0x109C84: init_threads (in /home/philosophers/philo/philo)
==3896==    by 0x109A17: init (in /home/philosophers/philo/philo)
==3896==    by 0x109E95: main (in /home/philosophers/philo/philo)
==3896==  Address 0x4a900d8 is 8 bytes inside a block of size 80 alloc'd
==3896==    at 0x484A919: malloc (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==3896==    by 0x109B35: init_threads (in /home/philosophers/philo/philo)
==3896==    by 0x109A17: init (in /home/philosophers/philo/philo)
==3896==    by 0x109E95: main (in /home/philosophers/philo/philo)
==3896==  Block was alloc'd by thread #1
==3896== ----------------------------------------------------------------
==3896==
==3896== Possible data race during read of size 1 at 0x1FFF000528 by thread #1
==3896== Locks held: none
==3896==    at 0x485077C: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==3896==    by 0x4850A2A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==3896==    by 0x1099B8: finish (in /home/philosophers/philo/philo)
==3896==    by 0x109EA4: main (in /home/philosophers/philo/philo)
==3896==
==3896== This conflicts with a previous write of size 4 by thread #2
==3896== Locks held: none
==3896==    at 0x48FEB10: __pthread_mutex_unlock_usercnt (pthread_mutex_unlock.c:62)
==3896==    by 0x48FEB10: pthread_mutex_unlock@@GLIBC_2.2.5 (pthread_mutex_unlock.c:368)
==3896==    by 0x4851248: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==3896==    by 0x1097A3: check_finish (in /home/philosophers/philo/philo)
==3896==    by 0x109715: dinner (in /home/philosophers/philo/philo)
==3896==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==3896==    by 0x48F9B42: start_thread (pthread_create.c:442)
==3896==    by 0x498ABB3: clone (clone.S:100)
==3896==  Address 0x1fff000528 is on thread #1's stack
==3896==  in frame #3, created by main (???:)
==3896==
==3896==
==3896== Use --history-level=approx or =none to gain increased speed, at
==3896== the cost of reduced accuracy of conflicting-access information
==3896== For lists of detected and suppressed errors, rerun with: -s
==3896== ERROR SUMMARY: 15 errors from 4 contexts (suppressed: 753 from 136)